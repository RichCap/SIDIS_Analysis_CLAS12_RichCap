#!/usr/bin/env python3

import argparse
import json
import os
import re


# --------------------------------------------------------------------------------------
# Parsing helpers for your known key formats
# --------------------------------------------------------------------------------------

_re_q2y_only = re.compile(r"Q2-y=(\d+)\s*,\s*Q2-y")
_re_zpt      = re.compile(r"Q2-y=(\d+)\s*,\s*z-pT=(\d+)")
_re_BC       = re.compile(r"^([BC])_(\d+)_(\d+)$")


def _normalize_minmax(vmin, vmax):
    if(vmin > vmax):
        return vmax, vmin
    return vmin, vmax


def parse_bin_edges_json(path):
    # Returns:
    #   q2y_edges: list of dict {idx,Q2_min,Q2_max,y_min,y_max}
    #   zpt_edges: list of dict {q2y_idx, idx, z_min,z_max,pT_min,pT_max}
    with open(path, "r") as f:
        j = json.load(f)

    q2y_edges = []
    zpt_edges = []

    for key, val in j.items():
        if(not isinstance(val, list) or len(val) != 4):
            continue

        v0, v1, v2, v3 = val[0], val[1], val[2], val[3]

        m1 = _re_q2y_only.search(key)
        if(m1):
            q2y = int(m1.group(1))
            Q2_max, Q2_min, y_max, y_min = float(v0), float(v1), float(v2), float(v3)
            Q2_min, Q2_max = _normalize_minmax(Q2_min, Q2_max)
            y_min, y_max   = _normalize_minmax(y_min, y_max)

            q2y_edges.append({
                "idx": q2y,
                "Q2_min": Q2_min,
                "Q2_max": Q2_max,
                "y_min":  y_min,
                "y_max":  y_max
            })
            continue

        m2 = _re_zpt.search(key)
        if(m2):
            q2y = int(m2.group(1))
            zpt = int(m2.group(2))
            z_max, z_min, pT_max, pT_min = float(v0), float(v1), float(v2), float(v3)
            z_min, z_max   = _normalize_minmax(z_min, z_max)
            pT_min, pT_max = _normalize_minmax(pT_min, pT_max)

            zpt_edges.append({
                "q2y_idx": q2y,
                "idx":     zpt,
                "z_min":   z_min,
                "z_max":   z_max,
                "pT_min":  pT_min,
                "pT_max":  pT_max
            })
            continue

    # Sort for determinism (nice diffs, reproducible builds)
    q2y_edges.sort(key=lambda e: e["idx"])
    zpt_edges.sort(key=lambda e: (e["q2y_idx"], e["idx"]))

    return q2y_edges, zpt_edges


def parse_modulations_json(path):
    # Returns:
    #   B_entries: list of dict {q2y,zpt,val}
    #   C_entries: list of dict {q2y,zpt,val}
    with open(path, "r") as f:
        j = json.load(f)

    B_entries = []
    C_entries = []

    for key, val in j.items():
        m = _re_BC.match(key)
        if(not m):
            continue
        if(not isinstance(val, (int, float))):
            continue

        kind = m.group(1)
        q2y  = int(m.group(2))
        zpt  = int(m.group(3))
        vv   = float(val)

        entry = {"q2y": q2y, "zpt": zpt, "val": vv}
        if(kind == "B"):
            B_entries.append(entry)
        else:
            C_entries.append(entry)

    B_entries.sort(key=lambda e: (e["q2y"], e["zpt"]))
    C_entries.sort(key=lambda e: (e["q2y"], e["zpt"]))

    return B_entries, C_entries


# --------------------------------------------------------------------------------------
# Code generation
# --------------------------------------------------------------------------------------

def write_generated_files(args, q2y_edges, zpt_edges, B_entries, C_entries):
    out_base_name = args.out_base_name
    os.makedirs(args.out_dir_hpp, exist_ok=True)
    os.makedirs(args.out_dir_cpp, exist_ok=True)

    hpp_path = os.path.join(args.out_dir_hpp, f"{out_base_name}.hpp")
    cpp_path = os.path.join(args.out_dir_cpp, f"{out_base_name}.cpp")

    guard = out_base_name.upper() + "_HPP"

    with open(hpp_path, "w") as hpp:
        hpp.write(f"""#pragma once

// Auto-generated. DO NOT EDIT BY HAND.
// Generated by Create_cpp_Compatible_Files_from_JSON.py

#include <cstddef>

namespace sidis::sf::set::measured_tables {{

struct Q2yBinEdge {{
\tint    idx;
\tdouble Q2_min;
\tdouble Q2_max;
\tdouble y_min;
\tdouble y_max;
}};

struct ZpTBinEdge {{
\tint    q2y_idx;
\tint    idx;
\tdouble z_min;
\tdouble z_max;
\tdouble pT_min;
\tdouble pT_max;
}};

struct ModEntry {{
\tint    q2y;
\tint    zpt;
\tdouble val;
}};

extern const Q2yBinEdge Q2Y_EDGES[];
extern const std::size_t Q2Y_EDGES_N;

extern const ZpTBinEdge ZPT_EDGES[];
extern const std::size_t ZPT_EDGES_N;

extern const ModEntry B_ENTRIES[];
extern const std::size_t B_ENTRIES_N;

extern const ModEntry C_ENTRIES[];
extern const std::size_t C_ENTRIES_N;

}} // namespace sidis::sf::set::measured_tables
""")

    with open(cpp_path, "w") as cpp:
        cpp.write(f"""// Auto-generated. DO NOT EDIT BY HAND.
// Generated by Create_cpp_Compatible_Files_from_JSON.py

#include "sidis/sf_set/{out_base_name}.hpp"

namespace sidis::sf::set::measured_tables {{

const Q2yBinEdge Q2Y_EDGES[] = {{
""")
        for e in q2y_edges:
            cpp.write(f"\t{{ {e['idx']}, {e['Q2_min']:.16e}, {e['Q2_max']:.16e}, {e['y_min']:.16e}, {e['y_max']:.16e} }},\n")
        cpp.write("};\n")
        cpp.write("const std::size_t Q2Y_EDGES_N = sizeof(Q2Y_EDGES) / sizeof(Q2Y_EDGES[0]);\n\n")

        cpp.write("const ZpTBinEdge ZPT_EDGES[] = {\n")
        for e in zpt_edges:
            cpp.write(f"\t{{ {e['q2y_idx']}, {e['idx']}, {e['z_min']:.16e}, {e['z_max']:.16e}, {e['pT_min']:.16e}, {e['pT_max']:.16e} }},\n")
        cpp.write("};\n")
        cpp.write("const std::size_t ZPT_EDGES_N = sizeof(ZPT_EDGES) / sizeof(ZPT_EDGES[0]);\n\n")

        cpp.write("const ModEntry B_ENTRIES[] = {\n")
        for e in B_entries:
            cpp.write(f"\t{{ {e['q2y']}, {e['zpt']}, {e['val']:.16e} }},\n")
        cpp.write("};\n")
        cpp.write("const std::size_t B_ENTRIES_N = sizeof(B_ENTRIES) / sizeof(B_ENTRIES[0]);\n\n")

        cpp.write("const ModEntry C_ENTRIES[] = {\n")
        for e in C_entries:
            cpp.write(f"\t{{ {e['q2y']}, {e['zpt']}, {e['val']:.16e} }},\n")
        cpp.write("};\n")
        cpp.write("const std::size_t C_ENTRIES_N = sizeof(C_ENTRIES) / sizeof(C_ENTRIES[0]);\n\n")

        cpp.write("} // namespace sidis::sf::set::measured_tables\n")

    return hpp_path, cpp_path


# --------------------------------------------------------------------------------------
# CLI
# --------------------------------------------------------------------------------------

def main():
    parser = argparse.ArgumentParser(description="Convert measured-SF JSON inputs into compiled C++ constant tables (no JSON lib needed).", formatter_class=argparse.ArgumentDefaultsHelpFormatter)

    parser.add_argument('-bej', "--bin-edges-json", 
                        default="/w/hallb-scshelf2102/clas12/richcap/SIDIS_Analysis/RC_Correction_Code/Full_Bin_Definition_Array.json",
                        type=str,
                        help="Path to bin-edges JSON (Q2-y and z-pT edges).")
    parser.add_argument("-mj", "--modulations-json", 
                        default="/w/hallb-scshelf2102/clas12/richcap/SIDIS_Analysis/Fit_Pars_from_3D_Bayesian_with_Toys.json",
                        type=str,
                        help="Path to modulations JSON (B_#, C_# keys).")
    parser.add_argument("-odh", "--out_dir_hpp", 
                        default="/w/hallb-scshelf2102/clas12/richcap/Radiative_MC/SIDIS_RC_EvGen_richcap/sidis/include/sidis/sf_set",
                        type=str,
                        help="Directory to write the generated '.hpp' file.")
    parser.add_argument("-odc", "--out_dir_cpp", 
                        default="/w/hallb-scshelf2102/clas12/richcap/Radiative_MC/SIDIS_RC_EvGen_richcap/sidis/src/sf_set",
                        type=str,
                        help="Directory to write the generated '.cpp' file.")
    parser.add_argument("-obn", "--out_base_name",
                        default="richcap_measured_sf_tables",
                        help="Base filename (no extension) for generated files.")

    args = parser.parse_args()

    q2y_edges, zpt_edges = parse_bin_edges_json(args.bin_edges_json)
    B_entries, C_entries = parse_modulations_json(args.modulations_json)

    hpp_path, cpp_path = write_generated_files(args, q2y_edges, zpt_edges, B_entries, C_entries)

    print("Wrote:")
    print(f"\thpp_path = {hpp_path}")
    print(f"\tcpp_path = {cpp_path}")
    print("\n\nCounts:")
    print(f"\tQ2-y edges: {len(q2y_edges)}")
    print(f"\tz-pT edges: {len(zpt_edges)}")
    print(f"\t B entries: {len(B_entries)}")
    print(f"\t C entries: {len(C_entries)}")


if(__name__ == "__main__"):
    main()
